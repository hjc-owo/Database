## 课本 p305

1. 事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。

   事务的 4 个特性(ACID 特性)：

   1. 原子性(Atomicity)
   2. 一致性(Consistency)
   3. 隔离性(Isolation)
   4. 持久性(Durability)

   故障恢复可以保证事务的原子性和持续性。

2. 事务执行的结果必须是是数据库从一个一致性状态变到另一个一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所做的修改有一部分已经写入物理数据库，这是数据库就可能处于不正确的状态，或者说是不一致的状态。

   例如：转账的事务 T1

   ```sql
   read(A)
   A := A – 100
   write(A)
   read(B)
   B := B + 100
   write(B)
   ```

   如果事务因为软硬件故障在第三步和第六步之间终止退出了，部分操作完成而部分操作未完成，则数据库会处于不一致状态，钱会丢失。

## 课本 p326

1. 数据库是共享资源，通常有多个事务同时在运行。当多个事务并发地存取数据库时，就会产生同时读取或修改同一数据的情况。若对并发操作不加控制，就有可能存取或存储不正确的数据，破坏数据库的一致性。所以数据库管理系统必须提供并发控制机制。

   并发控制可以保证事务的一致性和隔离性。

2. 并发操作带来的数据不一致性包括三类。

   1. 丢失修改：丢失修改是指事务1与事务2从数据库中读入同一数据并修改，事务2的提交结果破坏了事务1提交的结果，导致事务1的修改被丢失。
   2. 不可重复读：不可重复读是指事务1读取数据后，事务2执行更新操作，使事务1无法再现前一次读取结果。
      1. 事务2对其做了修改，当事务1再次读该数据时，得到与前一次不同的值。
      2. 事务2删除了其中部分记录，当事务1再次读取数据时，发现某些记录神密地消失了。
      3. 事务2插入了一些记录，当事务1再次按相同条件读取数据时，发现多了一些记录。
   3. 读“脏”数据：事务1修改某一数据，并将其写回磁盘。事务2读取同一数据后，事务1由于某种原因被撤消，这时事务1已修改过的数据恢 复原值，事务2读到的数据就与数据库中的数据不一致，是不正确的数据，又称为“脏”数据。

   避免不一致性的方法就是并发控制。常用的并发控制技术包括封锁方法、时间戳方法、乐观控制方法和多版本并发控制方法。

3. 封锁就是事务T在对某个数据对象(例如表、记录等)操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。

   基本的封锁类型

   1. 排它锁(eXclusive lock，简记为X锁)

      排它锁又称为写锁。若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁

   2. 共享锁(Share lock，简记为S锁)

      共享锁又称为读锁。若事务T对数据对象A加上S锁，则其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务在T释放R上的S锁之前，只能读取R，而不能再对R作任何修改。

4. DBMS 在对数据库进行读写操作之前首先对该数据进行封锁操作，按照一定的封锁协议对并发操作进行控制，使得多个并发操作有序地执行，就可以避免丢失修改、不可重复读、读“脏”数据等数据不一致性。

5. <null>

6. 死锁：如果事务1封锁了数据A，事务2封锁了数据B，然后事务1又请求封锁数据B，因为事务2已经封锁了B，于是事务1等待事务2释放B上的锁。接着事务2又申请封锁A，因为事务1已经封锁了A，事务2也只能等待事务1释放A上的锁。这样就出现了事务1等待事务2，事务2等待事务1的局面，事务1和事务2两个事务永远不能结束，，形成死锁。

   | 事务1     | 事物2     |
   | --------- | --------- |
   | Lock_X(A) |           |
   |           | Lock_S(B) |
   |           | Read(B)   |
   |           | Lock_S(A) |
   | Read(A)   | wait      |
   | A: = A-50 |           |
   | Write(A)  |           |
   | Lock_X(B) |           |
   | wait      |           |

   预防死锁的发生就是要破坏产生死锁的条件。

   1. 一次封锁法：要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。
   2. 顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按照这个顺序实行封锁。

7. 数据库系统一般采用的方法是允许死锁发生，DBMS 检测到死锁后加以解除。DBMS 中诊断死锁的方法一般采用等待图法检测死锁。

   DBMS 并发控制子系统检测到死锁后，就要设法解除。通常采用的方法是选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有锁，使其他事务得以继续运行下去。

8. 可串行化的调度是正确的调度。

9. 

   1. 所有可能的结果
      | 调度顺序   | 结果 |
      | ---------- | ---- |
      | T1, T2, T3 | 16   |
      | T1, T3, T2 | 8    |
      | T2, T1, T3 | 4    |
      | T2, T3, T1 | 2    |
      | T3, T1, T2 | 4    |
      | T3, T2, T1 | 2    |

   2. 可串行化的调度
      | T1          | T2          | T3           |
      | ----------- | ----------- | ------------ |
      | Slock(A)    |             |              |
      | Y = A = 0   |             |              |
      | Unlock(A)   |             |              |
      | Xlock(A)    |             |              |
      |             | Slock(A)    |              |
      | A = Y + 2   | wait        |              |
      | 写回 A(= 2) | wait        |              |
      | Unlock(A)   | wait        |              |
      |             | Y = A = 2   |              |
      |             | Unlock(A)   |              |
      |             | Xlock(A)    |              |
      |             |             | Slock(A)     |
      |             | A = Y * 2   | wait         |
      |             | 写回 A(= 4) | wait         |
      |             | Unlock(A)   | wait         |
      |             |             | Y = A = 4    |
      |             |             | Unlock(A)    |
      |             |             | Xlock(A)     |
      |             |             | A = Y * Y    |
      |             |             | 写回 A(= 16) |
      |             |             | Unlock(A)    |

      结果是 16，是串行的。
      
   3. 非串行化的调度

      | T1          | T2          | T3          |
      | ----------- | ----------- | ----------- |
      | Slock(A)    |             |             |
      | Y = A = 0   |             |             |
      | Unlock(A)   |             |             |
      |             | Slock(A)    |             |
      |             | Y = A = 0   |             |
      | Xlock(A)    |             |             |
      | wait        | Unlock(A)   |             |
      | A = Y + 2   |             |             |
      | 写回 A(= 2) |             | Slock(A)    |
      | Unlock(A)   |             | wait        |
      |             |             | Y = A = 2   |
      |             |             | Unlock(A)   |
      |             |             | Xlock(A)    |
      |             | Xlock(A)    |             |
      |             | wait        | A = Y * Y   |
      |             | wait        | 写回 A(= 4) |
      |             | wait        | Unlock(A)   |
      |             | A = Y * 2   |             |
      |             | 写回 A(= 0) |             |
      |             | Unlock(A)   |             |

      结果是 0，不是串行的。

   4. 不死锁的

      | T1          | T2          | T3           |
      | ----------- | ----------- | ------------ |
      | Slock(A)    |             |              |
      | Y = A = 0   |             |              |
      | Unlock(A)   |             |              |
      | Xlock(A)    |             |              |
      | A = Y + 2   | Slock(A)    |              |
      | 写回 A(= 2) | wait        |              |
      | Unlock(A)   | wait        |              |
      |             | Y = A = 2   |              |
      |             | Unlock(A)   |              |
      |             | Xlock(A)    |              |
      | Unlock(A)   | wait        | Slock(A)     |
      |             | A = Y * 2   | wait         |
      |             | 写回 A(= 4) | wait         |
      |             | Unlock(A)   | wait         |
      |             |             | Y = A = 4    |
      |             | Unlock(A)   |              |
      |             |             | Xlock(A)     |
      |             |             | A = Y * Y    |
      |             |             | 写回 A(= 16) |
      |             |             | Unlock(A)    |
      |             |             | Unlock(A)    |

   5. 产生死锁的

      | T1        | T2        | T3        |
      | --------- | --------- | --------- |
      | Slock(A)  |           |           |
      | Y = A = 0 |           |           |
      |           | Slock(A)  |           |
      |           | Y = A = 0 |           |
      | Xlock(A)  |           |           |
      | wait      |           |           |
      |           | Xlock(A)  |           |
      |           | wait      |           |
      |           |           | Slock(A)  |
      |           |           | Y = A = 0 |
      |           |           | Xlock(A)  |
      |           |           | wait      |

10. $r_3(B)r_1(A)w_3(B)r_2(B)r_2(A)w_2(B)r_1(B)w_1(A)$

    把$r_1(A)$往后移，得到$r_3(B)w_3(B)r_2(B)r_2(A)w_2(B)r_1(A)r_1(B)w_1(A)$，这个修改不发生冲突。

    得到的结果是串行的，所以原调度是冲突可串行化的。

11. <null>

12. | T1          | T2          |
    | ----------- | ----------- |
    | Slock(B)    |             |
    | Read(B = 2) |             |
    | Y = B       |             |
    | Unlock(B)   |             |
    | Xlock(A)    |             |
    |             |             |
    |             | Slock(A)    |
    | A = Y + 1   | wait        |
    | 写回 A(= 3) | wait        |
    | Unlock(A)   | wait        |
    |             | Slock(A)    |
    |             | Read(A = 3) |
    |             | X = A       |
    |             | Unlock(A)   |
    |             | Xlock(B)    |
    |             | B = X + 1   |
    |             | 写回 B(= 4) |
    |             | Unlock(B)   |

13. 遵循两阶段封锁（2PL）的调度 $\subset$ 正确的调度 = 可串行化的调度

    串行调度 $\subset$ 正确的调度

14. 1. | T1        | T2        |
       | --------- | --------- |
       | Slock(A)  | Slock(B)  |
       | R(A)      | R(B)      |
       | Xlock(B)  | Xlock(A)  |
       | R(B)      | R(A)      |
       | B = A + B | A = A + B |
       | W(B)      | W(A)      |
       | Unlock(A) | Unlock(B) |
       | Unlock(B) | Unlock(A) |

    2. 可能产生死锁：

       | T1       | T2       |
       | -------- | -------- |
       | Slock(A) |          |
       | R(A)     |          |
       |          | Slock(B) |
       |          | R(B)     |
       | Xlock(B) |          |
       |          | Xlock(A) |

       
