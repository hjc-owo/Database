- 什么是索引? 

  > 在关系型数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单（类似于图书目录，通过图书页码迅速找到所需内容）。一个索引是存储的表中一个特定列的值数据结构。索引是在表的列上创建。索引包含一个表中列的值，并且这些值存储在一个数据结构中。

- 简述 B 树索引、Hash 索引及聚簇索引的实现原理和优缺点。

  > 1. B 树索引
  >
  >    1. 实现原理
  >
  >       - 将数据存储块组织成一棵树。
  >
  >       - 这棵树是平衡的(B即Balance的首字母)，即从树根到树叶的所有路径一样长。
  >
  >       - 通常 B+ 树有三层：根、中间层和叶，当然也可以为任意层。
  >
  >       - 最底层的叶节点包含每个索引键和指向被索引行的行id
  >
  >       - 叶节点之间有通道可供平行查询
  >
  >       - 每一个叶节点都和磁盘页面大小一致
  >
  >       - 插入过程
  >
  >         设法在适当的叶结点中为新键找到空闲空间，如果有的话，就把键放在那里
  >
  >         如果在适当的叶结点中没有空间，就把该叶结点分裂成两个，并且把其中的键分到这两个新结点中，使每个新节点有一半或刚好超过一半的键。
  >         某一层的结点分裂在其上一层看来，相当于是要在这一较高的层次上插入一个新的键-指针对。因此，我们可以在这一较高层次上逆规地使用这个插入策略；如果有空间，则插入；如果没有，则分裂这个父结点且继续向树的高层推进。
  >
  >         例外的情况是，如果试图插入键到根结点中并且根结点没有空间，那么我们就分裂根结点成两个结点，且在更上一层创建一个新的结点。这个新的根结点有两个刚分裂成的结点作为它的子结点。
  >
  >    2. 优点
  >
  >       - 全值匹配：指的是和索引中所有列进⾏匹配。假设以（姓，名，出⽣⽇期）三个数据项建⽴复合索引，那么可以查找姓名为张三，出⽣⽇期在2000-12-12的⼈
  >       - 匹配最左前缀：假设以（姓，名，出⽣⽇期）三个数据项建⽴复合索引，可以查找所有姓张的⼈
  >       - 匹配列前缀：假设有姓为司徒，司马的⼈，我们也可以查找第⼀列的前缀部分，如查找所有以司开头的姓的⼈
  >       - 匹配范围值：可以查找所有在李和张之间的姓的⼈，注意范围查询只在复合索引的优先排序的第⼀列。（假设姓名按照拼⾳排序）
  >       - 精确匹配前⾯列并范围匹配后⼀列：可以查找姓李并出⽣⽇期在2000-12-12之后的⼈或姓名为张三并出⽣⽇期在2000-12-12之后的⼈，注意范围第⼀个范围查询后⾯的列⽆法再使⽤索引查询
  >       - 只访问索引的查询：即查询只需访问索引，⽽⽆需访问数据⾏。（此时应想到索引中的覆盖索引）
  >
  >    3. 缺点
  >
  >       - 如果不是按照索引的最左列开始查找，则⽆法使⽤索引。如⽆法查找名为龙的⼈，也⽆法查找在2000-12-12之后出⽣的⼈，当然也⽆法查找姓中以龙结尾的⼈（注意为和含有的区别）
  >       - 不能跳过索引中的列：⽆法查找姓李并在2000-12-12之后出⽣的⼈
  >       - 如果查询中包括某个列的范围查询，则其右边所有列都⽆法使⽤索引优化查询
  >
  > 2. Hash 索引
  >
  >    1. 实现原理
  >
  >       根据给定索引值，用一种算法将记录分散存储到多个“桶”中（一般一个桶就是一个数据块，块中内容用一次磁盘操作就可以读取到内存中）。当要查找记录时，用相同算法算出该记录所在的桶，读取整个桶的数据到内存中，然后在桶中顺序查找要找的纪录。
  >
  >    2. 优点
  >
  >       快速查询：参与索引的字段只要进⾏Hash运算之后就可以快速定位到该记录，时间复杂度约为1
  >
  >    3. 缺点
  >
  >       - 哈希索引只包含哈希值和⾏指针，所以不能⽤索引中的值来避免读取⾏
  >       - 哈希索引数据并不是按照索引值顺序存储的，所以也就⽆法⽤于排序和范围查询
  >       - 哈希索引也不⽀持部分索引列查询，因为哈希索引始终是使⽤索引列的全部数据进⾏哈希计算的。
  >       - 哈希索引只⽀持等值⽐较查询，如 =，IN()，<=> 操作
  >       - 如果哈希冲突较多，⼀些索引的维护操作的代价也会更⾼
  >
  > 3. 聚簇索引
  >
  >    1. 实现原理
  >       - 建立聚簇索引后，数据在物理文件中的存放位置不再是无序的，而是根据索引中键值的逻辑顺序决定了表中相应行的物理顺序。
  >       - 聚簇索引也叫簇类索引，是一种对磁盘上实际数据重新组织以按指定的一个或多个列的值排序。由于聚簇索引的索引页面指针指向数据页面，所以使用聚簇索引查找数据几乎总是比使用非聚簇索引快。每张表只能建一个聚簇索引，并且建聚簇索引需要至少相当该表 120% 的附加空间，以存放该表的副本和索引中间页。
  >    2. 优点
  >       - 可以把相关数据保存在一起，例如可以根据用户 id 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件，如果没有使用聚簇索引，那么每一封邮件都可能导致一次磁盘的 I/O。
  >       - 访问数据更快，聚簇索引将索引和数据保存在一个 B+ 树上，因为比非聚簇索引获取数据更快，非聚簇索引还得回表到聚簇索引上根据主键查询需要的数据行。
  >       - 使用索引覆盖扫描的查询可以直接使用页节点中的主键值。
  >    3. 缺点
  >       - 插入速度严重依赖于插入顺序，按照主键的顺序插入是加载数据页到InnoDB表中速度最快的方式。但是如果不按照主键顺序加载数据，那么在加载完成后最好使用 optimize table 命令重新组织一下表。
  >       - 更新聚簇索引列的代价很高，因为会强制 InnoDB 将每个被更新的行移动到新的位置。插入的时候会面临页分裂的问题。页分裂会导致表占用更多的磁盘空间。
  >       - 二级索引可能比想象的大，因为二级索引的叶子结点保存了引用行的主键
  >       - 二级索引访问需要两次索引查找，要回表，对于innodb，自适应hash索引能够减少这样的重复工作

- 试述查询优化的作用和一般步骤。

  > 1. 作用
  >
  >    - 查询是数据库最主要的功能之一，使用频率高。查询快慢直接影响系统效率。（不恰当的查询方式会拖累硬件效率）
  >
  >    - 查询处理的代价取决于磁盘的访问。（数据库涉及大量数据，内存无法完全存放，需要借助外部储存设备）
  >    - 查询优化是关系数据库管理系统的关键技术⼜是关系数据库管理系统的优点所在
  >    - 减轻了⽤户对于底层存取路径的负担，只需要关注查询的正确表达上⾯，⽽不需要关注查询的效率。
  >    - 系统优化后的程序往往⽐⽤户程序做的更好
  >    2. 一般步骤
  > 
  >   - 将查询转换成某种内部表示，通常是语法树
  > - 根据一定的等价变换规则把语法树转换成标准 (优化）形式 （代数优化）
  >   - 选择低层的操作算法(物理优化)
  >   - 对于语法树中的每一个操作计算各种执行算法的执 行代价
  >     - 选择代价小的执行算法
  > - 生成查询计划(查询执行方案)