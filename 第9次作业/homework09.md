## 课本p305

3. 把对数据的修改写到数据库中和把表示这个修改的日志记录写到日志文件中是两个不同的操作。有可能在这两个操作之间发生故障，即这两个写操作只完成了一个。

   如果先写了数据库修改，而在运行记录中没有登记这个修改，则以后就无法恢复这个修改了。如果先写日志，但没有修改数据库，在恢复时只不过是多执行一次 UNDO 操作，并不会影响数据库的正确性。所以一定要先写日志文件，即首先把日志记录写到日志文件中，然后写数据库的修改。

4. 重做和回滚的事务：
   
   |      | 重做      | 回滚      |
   | ---- | --------- | --------- |
   | ①    | $T_1,T_3$ | $T_2,T_4$ |
   | ②    | $T_1$     | $T_2,T_3$ |
   | ③    | $T_1$     | $T_2,T_3$ |
   | ④    | $T_1$     | $T_2$     |
   
5. 系统恢复后 $A,B,C$ 的值：

   |      | $A$  | $B$  | $C$  |
   | ---- | ---- | ---- | ---- |
   | ①    | 8    | 7    | 11   |
   | ②    | 10   | 0    | 11   |
   | ③    | 10   | 0    | 11   |
   | ④    | 10   | 0    | 11   |
   | ⑤    | 10   | 0    | 11   |
   | ⑥    | 0    | 0    | 0    |
   
5. 不同的故障，给出恢复方法。

   1. 事务故障的恢复机制：
      1. 反向扫描日志文件，查找该事务的更新操作。
      2. 对该事务的更新操作进行逆操作。即将事务日志中“更新前的值”写进数据库。
      3. 直到读到此事务的开始标记，该事务的恢复就完成了。
   2. 系统故障的恢复机制：
      1. 正向扫描日志文件，找出在故障发生前已经提交的事务队列（REDO 队列）和未完成的事务队列（UNDO 队列）。
      2. 对未完成的事务队列中的各个事务进行 UNDO 处理。
      3. 对已经提交事务队列中的各个事务进行 REDO 处理。
   3. 介质故障的恢复机制：
      1. 装入最新的数据库后备副本（离故障发生时刻最近的转储副本），使数据库恢复到最近一次转储时的一致性状态。
      2. 装入转储结束时刻的日志文件副本。
      3. 启动系统恢复命令，由 DBMS 完成恢复功能，即重做已完成的事务。
   
7. 在日志文件中增加检查点记录(checkpoint record) 

   增加一个重新开始文件

   数据库在登录日志文件期间动态地维护日志

   内容：

   1. 建立检查点时刻所有正在执行的事务清单
   2. 这些事务最近一个日志记录的地址

8. 利用日志技术进行数据库恢复时，恢复子系统必须搜索整个日志，这将耗费大量的时间。此外，需要 REDO 处理的事务实际上已经将它们的更新操作结果写到数据库中了，恢复子系统又重新执行了这些操作，浪费了大量时间。检查点技术就是为了解决这些问题。

   例如：

   1. 在使用检查点技术之前，需要从头扫描一遍日志文件，而利用检查点技术，只需要从检查点那一时刻开始扫描即可。
   2. 如果有事务在检查点之前完成并提交，进行恢复时，这个事务就不需要再进行 REDO 处理，检查点技术就可以做到这一点。

9. 检查点方法进行恢复的步骤。

   1. 检查点之前提交的事务不需要恢复

   2. 对于检查点之后才提交的事务，其恢复过程

      1. 从重新开始文件中找到最后一个检查点记录在日志文件中的地址

      2. 由该地址在日志文件中找到最后一个检查点记录
      3. 由该检查点记录得到检查点建立时刻所有正在执行的事务
      4. 从检查点开始正向扫描日志文件，直到日志文件结束，对读到的事务建立已提交和未提交队列
      5. 对已提交事务进行 Redo 操作，对未提交事务进 Undo 操作

## ppt最后的练习

1. undo-

   从后往前看，首先 $\lt \mathrm{commit\ }U \gt$，所以我们后面不考虑事务 $U$；

   然后 $\lt T,C,30,31 \gt$，将 $C$ 重新写回 30；

   接着 $\lt T,A,10,11 \gt$，将 $A$ 重新写回 10；

   最后 $\lt \mathrm{start\ }T \gt$，不用管；

   读到了日志文件开头，恢复结束。

2. redo-

   首先判断事务 $T$ 未完成，所以事务 $T$ 不用管；事务 $U$ 已完成，对事务 $U$ 进行 redo 操作。

   从前往后看， $\lt U,B,20,21 \gt$，将 $B$ 更新成 21；

   $\lt U,D,40,41 \gt$，将 $D$ 更新成 41；

   $\lt \mathrm{commit\ }U \gt$，读到文件末尾，恢复结束。

3. undo-/redo-

   即上面两个都要做一遍。
